package main

import (
	"flag"
	"github.com/marguerite/util/slice"
	"github.com/openSUSE/fonts-config/font"
	"io/ioutil"
	"reflect"
	"strings"
)

func errChk(e error) {
	if e != nil {
		panic(e)
	}
}

type lang struct {
	Name  string
	Sans  []string
	Serif []string
}

type langs []lang

func (l *langs) add(language, name string) {
	lv := reflect.ValueOf(l).Elem()
	hasLang := false
	generic := font.GenericFamily(name)
	for i := 0; i < lv.Len(); i++ {
		if lv.Index(i).FieldByName("Name").String() == language {
			hasLang = true
			hasFont := false
			fonts := reflect.Value{}
			if strings.HasPrefix(generic, "sans") {
				fonts = lv.Index(i).FieldByName("Sans")
			} else {
				fonts = lv.Index(i).FieldByName("Serif")
			}
			for j := 0; j < fonts.Len(); j++ {
				if fonts.Index(j).String() == name {
					hasFont = true
				}
			}
			if !hasFont {
				fonts.Set(reflect.Append(fonts, reflect.ValueOf(name)))
			}
		}
	}
	if !hasLang {
		if strings.HasPrefix(generic, "sans") {
			lv.Set(reflect.Append(lv, reflect.ValueOf(lang{language, []string{name}, []string{}})))
		} else {
			lv.Set(reflect.Append(lv, reflect.ValueOf(lang{language, []string{}, []string{name}})))
		}
	}
}

func main() {
	var file string
	flag.StringVar(&file, "file", "noto.json", "the noto.json file.")
	flag.Parse()

	js, err := ioutil.ReadFile(file)
	errChk(err)

	collection := font.Collection{}
	err = collection.Decode(js)
	errChk(err)

	ttGroup := "<?xml version=\"1.0\" ?>\n<!DOCTYPE fontconfig SYSTEM \"fonts.dtd\">\n<fontconfig>\n<!-- Generated by /usr/lib/fonts-config/generate_noto_config -->\n"
	nonTTGroup := ttGroup
	defaultFamily := ttGroup
	preferredLang := ttGroup
	genericFonts := []string{
		"Noto Sans",
		"Noto Sans Disp",
		"Noto Sans Display",
		"Noto Sans Mono",
		"Noto Sans Symbols",
		"Noto Sans Symbols2",
		"Noto Serif",
		"Noto Serif Disp",
		"Noto Serif Display",
		"Noto Mono",
	}
	languages := langs{}
	languagesPtr := &languages

	for _, f := range collection {
		// font_type
		if f.Hinting {
			ttGroup += font.GenerateFontTypeByHinting(f)
		} else {
			nonTTGroup += font.GenerateFontTypeByHinting(f)
		}

		// default family
		next := false

		for _, v := range f.Name {
			defaultFamily += font.GenerateDefaultFamily(v)
			if ok, _ := slice.Contains(genericFonts, v); ok {
				next = true
			}
		}

		// skip "generic" fonts that every language uses.
		if next {
			continue
		}

		// preferred language
		unstyledNames := font.GetUnstyledFontName(f)

		for _, l := range f.Lang {
			// skip emoji fonts
			if l == "und-zsye" {
				continue
			}
			// skip empty langugage
			if len(l) == 0 {
				continue
			}
			for _, v := range unstyledNames {
				languagesPtr.add(l, v)
			}
		}
	}

	for _, l := range languages {
		if len(l.Sans) > 0 {
			preferredLang += font.GenerateFamilyPreferListForLang("sans-serif", l.Name, l.Sans)
		}
		if len(l.Serif) > 0 {
			preferredLang += font.GenerateFamilyPreferListForLang("serif", l.Name, l.Serif)
		}
	}

	ttGroup += "</fontconfig>"
	nonTTGroup += "</fontconfig>"
	defaultFamily += "</fontconfig>"
	preferredLang += "</fontconfig>"

	err = ioutil.WriteFile("10-group-tt-hinted-noto.conf", []byte(ttGroup), 0644)
	errChk(err)
	err = ioutil.WriteFile("10-group-non-tt-hinted-noto.conf", []byte(nonTTGroup), 0644)
	errChk(err)
	err = ioutil.WriteFile("49-family-default-noto.conf", []byte(defaultFamily), 0644)
	errChk(err)
	err = ioutil.WriteFile("59-family-prefer-lang-specific-noto.conf", []byte(preferredLang), 0644)
	errChk(err)
}
