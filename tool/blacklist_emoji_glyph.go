package main

import (
	"flag"
	"fmt"
	"github.com/marguerite/util/dirutils"
	"github.com/marguerite/util/fileutils"
	"github.com/marguerite/util/slice"
	"github.com/openSUSE/fonts-config/font"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

func readFontFilesFromDir(d string) []string {
	files, _ := dirutils.Ls(d, "file")
	fonts := []string{}

	for _, f := range files {
		file := filepath.Base(f)
		if fileutils.HasPrefixSuffixInGroup(file, []string{"fonts", "."}, true) || strings.HasSuffix(file, ".dir") || strings.Contains(file, "Emoji") {
			continue
		}
		fonts = append(fonts, f)
	}
	return fonts
}

func generateBlacklistConfig(f font.EnhancedFont) string {
	conf := "\t<match target=\"scan\">\n\t\t<test name=\"family\">\n\t\t\t<string>" + f.Name[0] + "</string>\n\t\t</test>\n"
	if !(f.Width == 0 && f.Weight == 0 && f.Slant == 0) {
		if f.Width != 100 {
			conf += "\t\t<test name=\"width\">\n\t\t\t<int>" + strconv.Itoa(f.Width) + "</int>\n\t\t</test>\n"
		}
		if f.Weight != 80 {
			conf += "\t\t<test name=\"weight\">\n\t\t\t<int>" + strconv.Itoa(f.Weight) + "</int>\n\t\t</test>\n"
		}
		if f.Slant != 0 {
			conf += "\t\t<test name=\"slant\">\n\t\t\t<int>" + strconv.Itoa(f.Slant) + "</int>\n\t\t</test>\n"
		}
	}
	conf += "\t\t<edit name=\"charset\" mode=\"assign\">\n\t\t\t<minus>\n\t\t\t\t<name>charset</name>\n"
	conf += font.CharsetToFontConfig(f.Charset)
	conf += "\t\t\t</minus>\n\t\t</edit>\n\t</match>\n\n"
	return conf
}

func appendBlacklist(b font.EnhancedFonts, f font.EnhancedFont) font.EnhancedFonts {
	if i, ok := b.Contains(f); ok {
		b[i].AppendCharset(f.Charset)
	} else {
		b = append(b, f)
	}
	return b
}

func main() {
	var emojiFont string
	var debug bool
	flag.BoolVar(&debug, "debug", false, "enable debug output")
	flag.StringVar(&emojiFont, "emoji", "NotoColorEmoji.ttf", "glyphs from this emoji font will escape.")
	flag.Parse()

	emojiFont = filepath.Join("/usr/share/fonts/truetype", emojiFont)

	if _, err := os.Stat(emojiFont); !os.IsNotExist(err) {
		files := readFontFilesFromDir("/usr/share/fonts/truetype")
		emojiCharset := font.BuildEmojiCharset(emojiFont)

		emojiConf := "<?xml version=\"1.0\"?>\n<!DOCTYPE fontconfig SYSTEM \"fonts.dtd\">\n<fontconfig>\n<!-- Generated by /usr/lib/fonts-config/blacklist_emoji_glyph -->\n"

		blacklist := font.EnhancedFonts{}

		for _, file := range files {
			charset := font.BuildCharset(file)
			in := font.IntersectCharset(charset, emojiCharset)

			if len(in) > 0 {
				names := font.GetName(file)
				if len(names) > 1 {
					s := font.Style{}
					s.Get(file)
					unstyled := font.GetUnstyledFontName(font.Font{names, []string{}, false})

					for _, f := range unstyled {
						c := font.EnhancedFont{font.Font{[]string{f}, []string{}, false}, in, s}
						blacklist = appendBlacklist(blacklist, c)
					}

					slice.Remove(&names, unstyled)

					for _, f := range names {
						c := font.EnhancedFont{font.Font{[]string{f}, []string{}, false}, in, font.Style{}}
						blacklist = appendBlacklist(blacklist, c)
					}
				} else {
					c := font.EnhancedFont{font.Font{[]string{names[0]}, []string{}, false}, in, font.Style{}}
					blacklist = appendBlacklist(blacklist, c)
				}
			}
		}

		for _, f := range blacklist {
			if debug {
				fmt.Println(f)
			}
			emojiConf += generateBlacklistConfig(f)
		}

		err := ioutil.WriteFile("81-emoji-blacklist-glyphs.conf", []byte(emojiConf), 0644)
		if err != nil {
			panic(err)
		}
	}
}
